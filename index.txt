import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.io.IOException;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;

public class ImageWebSocketHandler extends TextWebSocketHandler {

    private static final String DATA_FOLDER = "./Data"; // Path to the folder where images are stored
    private static final Logger LOGGER = Logger.getLogger(ImageWebSocketHandler.class.getName());
    private static final int MAX_RETRIES = 5; // Maximum number of retries when reading an image file
    private static final int RETRY_DELAY_MS = 200; // Delay between retries in milliseconds
    private final Map<String, List<String>> userImages = new ConcurrentHashMap<>(); // Map to store user IDs and their corresponding image paths
    private final Map<String, WebSocketSession> userSessions = new ConcurrentHashMap<>(); // Map to store user IDs and their WebSocket sessions

    public ImageWebSocketHandler() {
        loadInitialUserImages(); // Load initial user images when the WebSocket handler is created
    }

    // Method to load initial user images from the DATA_FOLDER directory
    private void loadInitialUserImages() {
        try {
            // Iterate over directories in the DATA_FOLDER directory
            Files.list(Paths.get(DATA_FOLDER))
                .filter(Files::isDirectory)
                .forEach(userDir -> {
                    String userId = userDir.getFileName().toString(); // Get the user ID from the directory name
                    userImages.put(userId, new ArrayList<>()); // Create a list to store image paths for the user
                    try {
                        // Iterate over image files in the user directory
                        Files.list(userDir)
                            .filter(Files::isRegularFile)
                            .map(Path::toString)
                            .sorted() // Sort image paths
                            .forEach(imagePath -> userImages.get(userId).add(imagePath)); // Add image path to the list
                    } catch (IOException e) {
                        LOGGER.severe("Error loading images for user " + userId + ": " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            LOGGER.severe("Error loading initial user directories: " + e.getMessage());
        }
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        super.afterConnectionEstablished(session);
        String userId = getUserIdFromSession(session); // Extract user ID from WebSocket session
        userSessions.put(userId, session); // Store WebSocket session with user ID
        sendInitialImages(session, userId); // Send initial images to the user
        watchUserFolder(userId, session); // Watch for new images in the user's folder
    }

    // Method to extract user ID from WebSocket session
    private String getUserIdFromSession(WebSocketSession session) {
        // Assume user ID is passed as a query parameter in the WebSocket URL
        String query = session.getUri().getQuery();
        String userId = query != null && query.startsWith("userId=") ? query.substring(7) : "defaultUser";
        LOGGER.info("Extracted userId: " + userId);
        return userId;
    }

    // Method to send initial images to the user
    private void sendInitialImages(WebSocketSession session, String userId) {
        List<String> images = userImages.get(userId); // Get list of image paths for the user
        if (images != null) {
            // Iterate over image paths and send images to the user
            for (String imageFile : images) {
                sendImageWithRetry(session, imageFile);
            }
        } else {
            LOGGER.warning("No images found for user: " + userId);
        }
    }

    // Method to watch for new images in the user's folder
    private void watchUserFolder(String userId, WebSocketSession session) {
        try {
            Path userFolderPath = Paths.get(DATA_FOLDER, userId); // Path to the user's folder
            WatchService watchService = FileSystems.getDefault().newWatchService(); // Create WatchService
            userFolderPath.register(watchService, StandardWatchEventKinds.ENTRY_CREATE); // Register user's folder with WatchService

            // Start a new thread to watch for file creation events
            new Thread(() -> {
                while (true) {
                    WatchKey key;
                    try {
                        key = watchService.take(); // Wait for the next watch key
                    } catch (InterruptedException e) {
                        return; // Exit thread if interrupted
                    }

                    for (WatchEvent<?> event : key.pollEvents()) {
                        WatchEvent.Kind<?> kind = event.kind();

                        if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                            // Get the file path of the newly created image
                            Path filePath = ((WatchEvent<Path>) event).context();
                            String fullPath = userFolderPath.resolve(filePath).toString();

                            // Ensure userImages map contains the userId
                            userImages.computeIfAbsent(userId, k -> new ArrayList<>());

                            // Add the new image path to the user's list of images
                            userImages.get(userId).add(fullPath);

                            // Send the new image to the user
                            sendImageWithRetry(session, fullPath);
                        }
                    }
                    key.reset(); // Reset the watch key for the next events
                }
            }).start();
        } catch (IOException e) {
            LOGGER.severe("Error watching folder for user " + userId + ": " + e.getMessage());
        }
    }

    // Method to send an image to the user with retry mechanism
    private void sendImageWithRetry(WebSocketSession session, String filePath) {
        int retries = 0;
        while (retries < MAX_RETRIES) {
            try {
                byte[] imageBytes = Files.readAllBytes(Paths.get(filePath));
                String base64Image = Base64.getEncoder().encodeToString(imageBytes);
                session.sendMessage(new TextMessage(base64Image)); // Send image data as a WebSocket message
                break; // Exit loop if image sent successfully
            } catch (IOException e) {
                retries++; // Increment retry counter
                LOGGER.warning("Error reading file, retrying (" + retries + "/" + MAX_RETRIES + "): " + e.getMessage());
                try {
                    Thread.sleep(RETRY_DELAY_MS); // Wait before retrying
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    LOGGER.severe("Thread interrupted: " + ie.getMessage());
                }
            }
        }
    }
}
