# Oracle Data Source Configuration
spring.datasource.url=jdbc:oracle:thin:@//<host>:<port>/<service_name>
spring.datasource.username=your_oracle_user
spring.datasource.password=your_oracle_password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# JPA/Hibernate Configuration (Adjust dialect as needed for your Oracle version)
spring.jpa.database-platform=org.hibernate.dialect.OracleDialect
spring.jpa.hibernate.ddl-auto=update  # Use 'create-drop' for testing, 'validate' or 'none' for production
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import java.time.Instant;

@Entity
@Table(name = "ACTIVE_SESSIONS")
public class SessionRecord {

    @Id // The primary key is the user ID
    private String userId;

    private Instant loginTime;
    private String location;

    // Constructors and Getters (omitted for brevity)
    public SessionRecord() {}
    
    public SessionRecord(String userId, Instant loginTime, String location) {
        this.userId = userId;
        this.loginTime = loginTime;
        this.location = location;
    }

    // Getters and Setters for JPA...
    public String getUserId() { return userId; }
    public Instant getLoginTime() { return loginTime; }
    public String getLocation() { return location; }
    // ...
}

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface SessionRepository extends JpaRepository<SessionRecord, String> {
    // This custom method will be used to retrieve all unique locations for metric 2
    List<SessionRecord> findAllBy();
}

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ActiveSessionService {

    private final SessionRepository sessionRepository;
    private final MeterRegistry meterRegistry;
    private final Counter totalSessionDuration;

    public ActiveSessionService(SessionRepository sessionRepository, MeterRegistry meterRegistry) {
        this.sessionRepository = sessionRepository;
        this.meterRegistry = meterRegistry;

        // --- 1. Counter for cumulative time (Requirement #3) ---
        this.totalSessionDuration = Counter.builder("user_session_duration_total")
                .description("Total time users have been logged in (in seconds).")
                .register(meterRegistry);

        // --- 2. Gauge for total active users (Requirement #1) ---
        // Micrometer observes the count of active rows in the DB on every scrape.
        Gauge.builder("active_users_current", sessionRepository, JpaRepository::count)
             .description("Total number of users currently logged into the platform.")
             .register(meterRegistry);
        
        // --- 3. Active Location Tracking (Requirement #2) ---
        // We manage the time series dynamically in login/logout as before.
    }

    @Transactional
    public void login(String userId, String location) {
        // 1. DB Session Management: Insert new row
        SessionRecord newSession = new SessionRecord(userId, Instant.now(), location);
        sessionRepository.save(newSession);

        // 2. Prometheus Metric Update: Active Location (Gauge)
        // Creates a time series: active_users_location{user_id="...", location="..."} -> 1
        meterRegistry.gauge("active_users_location", 
                             List.of(Tag.of("user_id", userId), Tag.of("location", location)), 
                             1);
    }

    @Transactional
    public void logout(String userId) {
        SessionRecord session = sessionRepository.findById(userId).orElse(null);

        if (session != null) {
            // 1. Calculate and Update Metrics
            Duration sessionDuration = Duration.between(session.getLoginTime(), Instant.now());
            double durationSeconds = sessionDuration.toSeconds();

            // Update Total Duration Counter (Requirement #3)
            meterRegistry.counter("user_session_duration_total", "user_id", userId)
                         .increment(durationSeconds);

            // 2. DB Session Management: Remove row
            sessionRepository.delete(session);

            // 3. Prometheus Metric Update: Remove Active Location Gauge
            // Remove the time series for this specific user/location.
            meterRegistry.getMeters()
                    .stream()
                    .filter(meter -> meter.getId().getName().equals("active_users_location") &&
                                     meter.getId().getTags().contains(Tag.of("user_id", userId)))
                    .forEach(meterRegistry::remove);
        }
    }
}import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ActiveSessionService {

    private final SessionRepository sessionRepository;
    private final MeterRegistry meterRegistry;
    private final Counter totalSessionDuration;

    public ActiveSessionService(SessionRepository sessionRepository, MeterRegistry meterRegistry) {
        this.sessionRepository = sessionRepository;
        this.meterRegistry = meterRegistry;

        // --- 1. Counter for cumulative time (Requirement #3) ---
        this.totalSessionDuration = Counter.builder("user_session_duration_total")
                .description("Total time users have been logged in (in seconds).")
                .register(meterRegistry);

        // --- 2. Gauge for total active users (Requirement #1) ---
        // Micrometer observes the count of active rows in the DB on every scrape.
        Gauge.builder("active_users_current", sessionRepository, JpaRepository::count)
             .description("Total number of users currently logged into the platform.")
             .register(meterRegistry);
        
        // --- 3. Active Location Tracking (Requirement #2) ---
        // We manage the time series dynamically in login/logout as before.
    }

    @Transactional
    public void login(String userId, String location) {
        // 1. DB Session Management: Insert new row
        SessionRecord newSession = new SessionRecord(userId, Instant.now(), location);
        sessionRepository.save(newSession);

        // 2. Prometheus Metric Update: Active Location (Gauge)
        // Creates a time series: active_users_location{user_id="...", location="..."} -> 1
        meterRegistry.gauge("active_users_location", 
                             List.of(Tag.of("user_id", userId), Tag.of("location", location)), 
                             1);
    }

    @Transactional
    public void logout(String userId) {
        SessionRecord session = sessionRepository.findById(userId).orElse(null);

        if (session != null) {
            // 1. Calculate and Update Metrics
            Duration sessionDuration = Duration.between(session.getLoginTime(), Instant.now());
            double durationSeconds = sessionDuration.toSeconds();

            // Update Total Duration Counter (Requirement #3)
            meterRegistry.counter("user_session_duration_total", "user_id", userId)
                         .increment(durationSeconds);

            // 2. DB Session Management: Remove row
            sessionRepository.delete(session);

            // 3. Prometheus Metric Update: Remove Active Location Gauge
            // Remove the time series for this specific user/location.
            meterRegistry.getMeters()
                    .stream()
                    .filter(meter -> meter.getId().getName().equals("active_users_location") &&
                                     meter.getId().getTags().contains(Tag.of("user_id", userId)))
                    .forEach(meterRegistry::remove);
        }
    }
}
